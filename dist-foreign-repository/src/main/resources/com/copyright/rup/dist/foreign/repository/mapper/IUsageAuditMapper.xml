<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="IUsageAuditMapper">

    <resultMap id="usageAuditItemResultMap" type="UsageAuditItem" extends="StoredEntityMapper.storedEntityResult">
        <result property="id" column="df_usage_audit_uid"/>
        <result property="usageId" column="df_usage_uid"/>
        <result property="actionType" column="action_type_ind"/>
        <result property="actionReason" column="action_reason"/>
    </resultMap>

    <resultMap id="usageBatchStatisticMap" type="UsageBatchStatistic">
        <result property="loadedCount" column="loaded_count"/>
        <result property="loadedAmount" column="loaded_sum"/>
        <result property="matchedCount" column="matched_count"/>
        <result property="matchedAmount" column="matched_sum"/>
        <result property="ntsWithDrawnCount" column="nts_withdrawn_count"/>
        <result property="ntsWithDrawnAmount" column="nts_withdrawn_sum"/>
        <result property="worksNotFoundCount" column="work_not_found_count"/>
        <result property="worksNotFoundAmount" column="work_not_found_sum"/>
        <result property="multipleMatchingCount" column="multiple_matching_count"/>
        <result property="multipleMatchingAmount" column="multiple_matching_sum"/>
        <result property="rhNotFoundCount" column="rh_not_found_count"/>
        <result property="rhNotFoundAmount" column="rh_not_found_sum"/>
        <result property="eligibleCount" column="rh_found_count"/>
        <result property="eligibleAmount" column="rh_found_sum"/>
        <result property="sendForRaCount" column="send_for_ra_count"/>
        <result property="sendForRaAmount" column="send_for_ra_sum"/>
        <result property="paidCount" column="paid_count"/>
        <result property="paidAmount" column="paid_sum"/>
    </resultMap>

    <resultMap id="usageStatisticResultMap" type="UsageStatistic">
        <result property="usageId" column="df_usage_uid"/>
        <result property="status" column="status"/>
        <result property="matching" column="matching_ms"/>
        <result property="rights" column="rights_ms"/>
        <result property="eligibility" column="eligibility_ms"/>
    </resultMap>

    <sql id="usageAuditItemColumns">
        df_usage_audit_uid,
        df_usage_uid,
        action_type_ind,
        action_reason,
        <include refid="StoredEntityMapper.additionalColumns"/>
    </sql>

    <insert id="insert" parameterType="UsageAuditItem">
        insert into ${schema}.df_usage_audit(
            <include refid="usageAuditItemColumns"/>
        ) values (
            #{id},
            #{usageId},
            #{actionType},
            #{actionReason},
            #{createDate},
            #{updateDate},
            #{createUser},
            #{updateUser},
            1
        )
    </insert>

    <delete id="deleteByBatchId" parameterType="string">
        delete from ${schema}.df_usage_audit
        where df_usage_uid in (
            select df_usage_uid
            from ${schema}.df_usage
            where df_usage_batch_uid = #{batchId})
    </delete>

    <delete id="deleteForArchivedByBatchId" parameterType="string">
        delete from ${schema}.df_usage_audit
        where df_usage_uid in (
            select df_usage_archive_uid
            from ${schema}.df_usage_archive
            where df_usage_batch_uid = #{batchId})
    </delete>

    <delete id="deleteByUsageId" parameterType="string">
        delete from ${schema}.df_usage_audit
        where df_usage_uid = #{usageId}
    </delete>

    <select id="findByUsageId" parameterType="string" resultMap="usageAuditItemResultMap">
        select
            <include refid="usageAuditItemColumns"/>
        from ${schema}.df_usage_audit
        where df_usage_uid = #{usageId}
        order by created_datetime desc
    </select>
    
    <select id="findBatchStatistic" parameterType="map" resultMap="usageBatchStatisticMap">
        select
            sum(nested.loaded_count) loaded_count,
            round(sum(nested.loaded_sum), 2) loaded_sum,
            sum(nested.work_found_count) matched_count,
            round(sum(nested.work_found_sum), 2) matched_sum,
            sum(nested.nts_withdrawn_count) nts_withdrawn_count,
            round(sum(nested.nts_withdrawn_sum), 2) nts_withdrawn_sum,
            sum(nested.work_not_found_count) work_not_found_count,
            round(sum(nested.work_not_found_sum), 2) work_not_found_sum,
            sum(nested.multiple_matching_count) multiple_matching_count,
            round(sum(nested.multiple_matching_sum), 2) multiple_matching_sum,
            sum(nested.rh_not_found_count) rh_not_found_count,
            round(sum(nested.rh_not_found_sum), 2) rh_not_found_sum,
            sum(nested.rh_found_count) rh_found_count,
            round(sum(nested.rh_found_sum), 2) rh_found_sum,
            sum(nested.send_for_ra_count) send_for_ra_count,
            round(sum(nested.send_for_ra_sum), 2) send_for_ra_sum,
            sum(nested.paid_count) paid_count,
            round(sum(nested.paid_sum), 2) paid_sum
        from (
            select
                case when (sum(nested.loaded_count) != 0) then nested.amount else 0 end loaded_sum,
                sum(nested.loaded_count) loaded_count,
                case when (sum(nested.nts_withdrawn_count) != 0) then nested.amount else 0 end nts_withdrawn_sum,
                sum(nested.nts_withdrawn_count) nts_withdrawn_count,
                case when (sum(nested.work_found_count) != 0) then nested.amount else 0 end work_found_sum,
                sum(nested.work_found_count) work_found_count,
                case when (sum(nested.work_not_found_count) != 0) then nested.amount else 0 end work_not_found_sum,
                sum(nested.work_not_found_count) work_not_found_count,
                case when (sum(nested.multiple_matching_count) != 0) then nested.amount else 0 end multiple_matching_sum,
                sum(nested.multiple_matching_count) multiple_matching_count,
                case when (sum(nested.rh_found_count) != 0) then nested.amount else 0 end rh_found_sum,
                sum(nested.rh_found_count) rh_found_count,
                case when (sum(nested.rh_not_found_count) != 0) then nested.amount else 0 end rh_not_found_sum,
                sum(nested.rh_not_found_count) rh_not_found_count,
                case when (sum(nested.send_for_ra_count) != 0) then nested.amount else 0 end send_for_ra_sum,
                sum(nested.send_for_ra_count) send_for_ra_count,
                case when (sum(nested.paid_count) != 0) then nested.amount else 0 end paid_sum,
                sum(nested.paid_count) paid_count
            from(
                select
                    <include refid="batchStatisticColumns"/>
                from ${schema}.df_usage_audit audit
                left join ${schema}.df_usage u on audit.df_usage_uid = u.df_usage_uid
                left join ${schema}.df_usage_batch ub on ub.df_usage_batch_uid = u.df_usage_batch_uid
                <include refid="batchStatisticWhere"/>
                union all
                select
                    <include refid="batchStatisticColumns"/>
                from ${schema}.df_usage_audit audit
                left join ${schema}.df_usage_archive u on audit.df_usage_uid = u.df_usage_archive_uid
                left join ${schema}.df_usage_batch ub on ub.df_usage_batch_uid = u.df_usage_batch_uid
                <include refid="batchStatisticWhere"/>
            ) nested
            group by nested.amount
        ) nested
    </select>

    <sql id="batchStatisticColumns">
        sum(u.gross_amount) amount,
        case when (audit.action_type_ind in ('LOADED', 'CREATED')) then count(1) else 0 end loaded_count,
        case when (audit.action_type_ind = 'ELIGIBLE_FOR_NTS' <include refid="actionTypeDateClause"/>) then count(1) else 0 end nts_withdrawn_count,
        case when (audit.action_type_ind = 'WORK_FOUND' <include refid="actionTypeDateClause"/>) then count(1) else 0 end work_found_count,
        case when (audit.action_type_ind = 'WORK_NOT_FOUND' <include refid="actionTypeDateClause"/>) then count(1) else 0 end work_not_found_count,
        case when (audit.action_type_ind = 'MULTIPLE_RESULTS' <include refid="actionTypeDateClause"/>) then count(1) else 0 end multiple_matching_count,
        case when (audit.action_type_ind = 'RH_FOUND' <include refid="actionTypeDateClause"/>) then count(1) else 0 end rh_found_count,
        case when (audit.action_type_ind = 'RH_NOT_FOUND' <include refid="actionTypeDateClause"/>) then count(1) else 0 end rh_not_found_count,
        case when (audit.action_type_ind = 'SENT_FOR_RA' <include refid="actionTypeDateClause"/>) then count(1) else 0 end send_for_ra_count,
        case when (audit.action_type_ind = 'PAID' <include refid="actionTypeDateClause"/>) then count(1) else 0 end paid_count
    </sql>

    <sql id="batchStatisticWhere">
        where ub.name = #{batchName}
        group by audit.action_type_ind, cast(audit.created_datetime as date)
    </sql>

    <sql id="actionTypeDateClause">
        <if test="null != date">
            and <![CDATA[cast(audit.created_datetime as date) = cast(#{date} as date)]]>
        </if>
    </sql>

    <select id="getUsageStatistic" parameterType="string" resultMap="usageStatisticResultMap">
        select
            external.df_usage_uid,
            case when (u.status_ind is not null) then u.status_ind else ua.status_ind end status,
            extract(milliseconds from (greatest (min(work_not_found_delta), min(multiple_result_delta), min(work_found_delta)))) matching_ms,
            extract(milliseconds from (greatest (min(rh_not_found_delta), min(rh_found_delta)))) rights_ms,
            extract(milliseconds from (min(eligible_delta))) eligibility_ms
        from (
            select
                df_usage_uid,
                case when (internal.action_type_ind = 'WORK_NOT_FOUND') then min(delta) else null end work_not_found_delta,
                case when (internal.action_type_ind = 'MULTIPLE_RESULTS') then min(delta) else null end multiple_result_delta,
                case when (internal.action_type_ind = 'WORK_FOUND') then min(delta) else null end work_found_delta,
                case when (internal.action_type_ind = 'RH_NOT_FOUND') then min(delta) else null end rh_not_found_delta,
                case when (internal.action_type_ind = 'RH_FOUND') then min(delta) else null end rh_found_delta,
                case when (internal.action_type_ind = 'ELIGIBLE') then min(delta) else null end eligible_delta
            from (
                select
                    a1.df_usage_uid,
                    a1.action_type_ind,
                    a1.created_datetime - max(a2.created_datetime) delta
                from ${schema}.df_usage_audit a1
                left join ${schema}.df_usage_audit a2
                    on a1.df_usage_uid = a2.df_usage_uid
                    and <![CDATA[a2.created_datetime < a1.created_datetime]]>
                where a1.df_usage_uid = #{usageId}
                    and a1.action_type_ind in ('WORK_NOT_FOUND', 'MULTIPLE_RESULTS', 'WORK_FOUND', 'RH_NOT_FOUND', 'RH_FOUND', 'ELIGIBLE')
                group by
                    a1.df_usage_uid,
                    a1.action_type_ind,
                    a1.created_datetime
            ) internal
            group by df_usage_uid, internal.action_type_ind
        ) external
        left join ${schema}.df_usage u on u.df_usage_uid = external.df_usage_uid
        left join ${schema}.df_usage_archive ua on ua.df_usage_archive_uid = external.df_usage_uid
        group by external.df_usage_uid, status
    </select>

</mapper>
