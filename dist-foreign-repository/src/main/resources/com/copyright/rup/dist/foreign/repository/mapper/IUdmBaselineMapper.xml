<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="IUdmBaselineMapper">

    <resultMap id="udmBaselineDtoResultMap" type="UdmBaselineDto" extends="StoredEntityMapper.storedEntityResult">
        <result property="id" column="df_udm_usage_uid"/>
        <result property="period" column="period"/>
        <result property="usageOrigin" column="usage_origin"/>
        <result property="originalDetailId" column="original_detail_id"/>
        <result property="wrWrkInst" column="wr_wrk_inst"/>
        <result property="systemTitle" column="system_title"/>
        <result property="detailLicenseeClassId" column="detail_licensee_class_id"/>
        <result property="detailLicenseeClassName" column="detail_licensee_class_name"/>
        <result property="aggregateLicenseeClassId" column="aggregate_licensee_class_id"/>
        <result property="aggregateLicenseeClassName" column="aggregate_licensee_class_name"/>
        <result property="surveyCountry" column="survey_country"/>
        <result property="channel" column="channel"/>
        <result property="typeOfUse" column="reported_type_of_use"/>
        <result property="annualizedCopies" column="annualized_copies"/>
    </resultMap>

    <sql id="udmBaselineFilter">
        <if test="null != filter.period">
            and <![CDATA[u.period = #{filter.period}]]>
        </if>
        <if test="null != filter.channel">
            and ub.channel = #{filter.channel}
        </if>
        <if test="null != filter.udmUsageOrigin">
            and ub.usage_origin = #{filter.udmUsageOrigin}
        </if>
        <if test="null != filter.detailLicenseeClasses and filter.detailLicenseeClasses.size() > 0">
            and
            <foreach collection="filter.detailLicenseeClasses" item="detailLicenseeClass" open="(" separator=" or " close=")">
                u.detail_licensee_class_id = #{detailLicenseeClass.id}
            </foreach>
        </if>
        <if test="null != filter.aggregateLicenseeClasses and filter.aggregateLicenseeClasses.size() > 0">
            and
            <foreach collection="filter.aggregateLicenseeClasses" item="aggregateLicenseeClass" open="(" separator=" or " close=")">
                dlc.aggregate_licensee_class_id = #{aggregateLicenseeClass.id}
            </foreach>
        </if>
        <if test="null != filter.reportedTypeOfUses and filter.reportedTypeOfUses.size() > 0">
            and
            <foreach collection="filter.reportedTypeOfUses" item="reportedTypeOfUse" open="(" separator=" or " close=")">
                u.reported_type_of_use = #{reportedTypeOfUse}
            </foreach>
        </if>
        <if test="null != filter.surveyCountry">
            and u.survey_country = #{filter.surveyCountry}
        </if>
        <if test="null != filter.wrWrkInst">
            and u.wr_wrk_inst = #{filter.wrWrkInst}
        </if>
        <if test="null != filter.systemTitle">
            and u.system_title = #{filter.systemTitle}
        </if>
        <if test="null != filter.surveyCountry">
            and u.survey_country = #{filter.surveyCountry}
        </if>
        <if test="null != filter.usageDetailId">
            and u.original_detail_id = #{filter.usageDetailId}
        </if>
        <if test="!filter.annualizedCopiesExpression.isEmpty()">
            <include refid="IUdmUsageMapper.filterExpression">
                <property name="column" value="u.annualized_copies"/>
                <property name="operator" value="filter.annualizedCopiesExpression.operator"/>
                <property name="fieldFirstValue" value="${filter.annualizedCopiesExpression.fieldFirstValue}"/>
                <property name="fieldSecondValue" value="${filter.annualizedCopiesExpression.fieldSecondValue}"/>
            </include>
        </if>
    </sql>

    <sql id="udmChooseSortProperty">
        <choose>
            <when test="sort.property == 'detailId'">
                u.df_udm_usage_uid <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'period'">
                u.period <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'usageOrigin'">
                ub.usage_origin <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'usageDetailId'">
                u.original_detail_id <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'wrWrkInst'">
                u.wr_wrk_inst <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'systemTitle'">
                u.system_title <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'detLcId'">
                u.detail_licensee_class_id <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'detLcName'">
                dlc.description <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'aggLcId'">
                alc.aggregate_licensee_class_id <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'aggLcName'">
                alc.description <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'surveyCountry'">
                u.survey_country <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'channel'">
                ub.channel <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'reportedTypeOfUse'">
                u.reported_type_of_use <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'annualizedCopies'">
                u.annualized_copies <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'createDate'">
                u.baseline_created_datetime <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'createUser'">
                u.baseline_created_by_user <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'updateDate'">
                u.updated_datetime <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'updateUser'">
                u.updated_by_user <include refid="IUsageMapper.direction"/>
            </when>
        </choose>
    </sql>

    <sql id="selectDtosByFilterSql">
        select
            df_udm_usage_uid,
            u.period,
            ub.usage_origin,
            u.original_detail_id,
            u.wr_wrk_inst,
            u.system_title,
            u.detail_licensee_class_id,
            dlc.description detail_licensee_class_name,
            alc.aggregate_licensee_class_id,
            alc.description aggregate_licensee_class_name,
            survey_country,
            ub.channel,
            u.reported_type_of_use,
            u.annualized_copies,
            u.baseline_created_datetime as created_datetime,
            u.baseline_created_by_user as created_by_user,
            u.updated_datetime,
            u.updated_by_user,
            u.record_version
        from ${schema}.df_udm_usage u
        join ${schema}.df_udm_usage_batch ub on u.df_udm_usage_batch_uid = ub.df_udm_usage_batch_uid
        join ${schema}.df_detail_licensee_class dlc on u.detail_licensee_class_id = dlc.detail_licensee_class_id
        join ${schema}.df_aggregate_licensee_class alc on alc.aggregate_licensee_class_id = dlc.aggregate_licensee_class_id
        where is_baseline_flag = true
            <include refid="IUdmBaselineMapper.udmBaselineFilter"/>
        order by
        <choose>
            <when test="null != sort">
                <include refid="IUdmBaselineMapper.udmChooseSortProperty"/>
            </when>
            <otherwise>
                updated_datetime desc
            </otherwise>
        </choose>,
        df_udm_usage_uid
        <include refid="IUsageMapper.ifPageable"/>
    </sql>

    <sql id="selectCountByFilterSql">
        select count(1)
        from ${schema}.df_udm_usage u
        join ${schema}.df_udm_usage_batch ub on u.df_udm_usage_batch_uid = ub.df_udm_usage_batch_uid
        join ${schema}.df_detail_licensee_class dlc on u.detail_licensee_class_id = dlc.detail_licensee_class_id
        join ${schema}.df_aggregate_licensee_class alc on alc.aggregate_licensee_class_id = dlc.aggregate_licensee_class_id
        where is_baseline_flag = true
            <include refid="IUdmBaselineMapper.udmBaselineFilter"/>
    </sql>

    <select id="findDtosByFilter" resultMap="udmBaselineDtoResultMap" parameterType="map" fetchSize="${usageSelectFetchSize}">
        <include refid="IUdmBaselineMapper.selectDtosByFilterSql"/>
    </select>

    <select id="findCountByFilter" parameterType="map" resultType="int">
        <include refid="IUdmBaselineMapper.selectCountByFilterSql"/>
    </select>

    <select id="removeFromBaseline" parameterType="map" resultType="string">
        update ${schema}.df_udm_usage
        set
            is_baseline_flag = false,
            baseline_created_by_user = null,
            baseline_created_datetime = null
        where status_ind != 'ELIGIBLE'
            and period = #{period}
            and is_baseline_flag = true
        returning df_udm_usage_uid
    </select>

    <select id="findPeriods" resultType="int">
        select distinct period
        from ${schema}.df_udm_usage
        where is_baseline_flag = true
        order by period desc
    </select>

    <select id="findNotPopulatedValuesFromBaseline" resultMap="IUdmValueMapper.udmValueResultMap">
        <!-- Selects periods with age weight greater than zero -->
        with prior_periods as (
            select periods.period
            from generate_series(1, (select count(*) from ${schema}.df_udm_age_weight where weight > 0 and period_prior > 0)) i
            cross join lateral (
                select to_char(to_date(#{period}::text, 'YYYYMM') - ((i * 6) || ' months')::INTERVAL, 'YYYYMM')::int as period
            ) periods
        )
        <!-- The following unique works are included into result:
             1. works that were not populated into value batch for given period
             2. works from previous periods with age weight greater than zero, that were not populated into value batch for any period -->
        select distinct on (u.wr_wrk_inst)
            #{period} as period,
            u.wr_wrk_inst,
            u.rh_account_number,
            u.system_title,
            u.standard_number
            <!-- TODO: u.standard_number_type -->
        from ${schema}.df_udm_usage u
        left join ${schema}.df_udm_value v on v.wr_wrk_inst = u.wr_wrk_inst
        where (u.period = #{period} or u.period in (select period from prior_periods))
            and u.is_baseline_flag = true
            and (v.wr_wrk_inst is null or (u.period = #{period} and v.period != #{period}))
        order by u.wr_wrk_inst, u.period desc
    </select>
</mapper>
