<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="IAclUsageMapper">

    <resultMap id="aclUsageDtoResultMap" type="AclUsageDto" extends="StoredEntityMapper.storedEntityResult">
        <result property="id" column="df_acl_usage_uid"/>
        <result property="usageBatchId" column="df_acl_usage_batch_uid"/>
        <result property="usageOrigin" column="usage_origin"/>
        <result property="channel" column="channel"/>
        <result property="period" column="period"/>
        <result property="originalDetailId" column="original_detail_id"/>
        <result property="wrWrkInst" column="wr_wrk_inst"/>
        <result property="systemTitle" column="system_title"/>
        <result property="detailLicenseeClass.id" column="detail_licensee_class_id"/>
        <result property="detailLicenseeClass.description" column="detail_licensee_class_name"/>
        <result property="aggregateLicenseeClassId" column="aggregate_licensee_class_id"/>
        <result property="aggregateLicenseeClassName" column="aggregate_licensee_class_name"/>
        <result property="surveyCountry" column="survey_country"/>
        <result property="publicationType.id" column="pub_type_id"/>
        <result property="publicationType.name" column="pub_type_name"/>
        <result property="publicationType.description" column="pub_type_description"/>
        <result property="contentUnitPrice" column="content_unit_price"/>
        <result property="typeOfUse" column="type_of_use"/>
        <result property="annualizedCopies" column="annualized_copies"/>
        <result property="quantity" column="quantity"/>
        <result property="editable" column="is_editable"/>
    </resultMap>

    <resultMap id="aclDefaultUsageAgeWeightResultMap" type="UsageAge" extends="StoredEntityMapper.storedEntityResult">
        <result property="period" column="period_prior"/>
        <result property="weight" column="weight"/>
    </resultMap>

    <resultMap id="aclRightsholderTotalsHolderResultMap" type="AclRightsholderTotalsHolder">
        <result property="rightsholder.name" column="rh_name"/>
        <result property="rightsholder.accountNumber" column="rh_account_number"/>
        <result property="grossTotalPrint" column="gross_total_print"/>
        <result property="grossTotalDigital" column="gross_total_digital"/>
        <result property="serviceFeeTotalPrint" column="service_fee_total_print"/>
        <result property="serviceFeeTotalDigital" column="service_fee_total_digital"/>
        <result property="netTotalPrint" column="net_total_print"/>
        <result property="netTotalDigital" column="net_total_digital"/>
        <result property="numberOfTitles" column="number_of_titles"/>
        <result property="numberOfAggLcClasses" column="number_of_agg_lc_classes"/>
        <result property="licenseType" column="license_type"/>
    </resultMap>

    <resultMap id="aclScenarioDetailResultMap" type="AclScenarioDetail" extends="StoredEntityMapper.storedEntityResult">
        <result property="id" column="df_acl_scenario_detail_uid"/>
        <result property="scenarioId" column="df_acl_scenario_uid"/>
        <result property="period" column="period_end_date"/>
        <result property="originalDetailId" column="original_detail_id"/>
        <result property="wrWrkInst" column="wr_wrk_inst"/>
        <result property="systemTitle" column="system_title"/>
        <result property="detailLicenseeClass.id" column="detail_licensee_class_id"/>
        <result property="detailLicenseeClass.description" column="detail_licensee_class_name"/>
        <result property="aggregateLicenseeClassId" column="aggregate_licensee_class_id"/>
        <result property="aggregateLicenseeClassName" column="aggregate_licensee_class_name"/>
        <result property="publicationType.id" column="publication_type_uid"/>
        <result property="publicationType.weight" column="pub_type_weight"/>
        <result property="publicationType.period" column="pub_type_period"/>
        <result property="contentUnitPrice" column="content_unit_price"/>
        <result property="quantity" column="usage_quantity"/>
        <result property="usageAgeWeight" column="usage_age_weight"/>
        <result property="weightedCopies" column="weighted_copies"/>
        <result property="surveyCountry" column="survey_country"/>
        <collection property="scenarioShareDetails" javaType="java.util.List" ofType="com.copyright.rup.dist.foreign.domain.AclScenarioShareDetail">
            <result property="rhAccountNumber" column="rh_account_number"/>
            <result property="typeOfUse" column="type_of_use"/>
            <result property="volumeWeight" column="volume_weight"/>
            <result property="valueWeight" column="value_weight"/>
            <result property="valueShare" column="value_share"/>
            <result property="volumeShare" column="volume_share"/>
            <result property="detailShare" column="detail_share"/>
            <result property="volumeWeightDenominator" column="volume_weight_denominator"/>
            <result property="valueWeightDenominator" column="value_weight_denominator"/>
            <result property="netAmount" column="net_amount"/>
            <result property="grossAmount" column="gross_amount"/>
            <result property="serviceFeeAmount" column="service_fee_amount"/>
        </collection>
    </resultMap>

    <sql id="aclUsageColumns">
        df_acl_usage_uid,
        df_acl_usage_batch_uid,
        usage_origin,
        channel,
        period,
        original_detail_id,
        wr_wrk_inst,
        system_title,
        detail_licensee_class_id,
        survey_country,
        publication_type_uid,
        content_unit_price,
        type_of_use,
        annualized_copies,
        quantity,
        <include refid="StoredEntityMapper.additionalColumns"/>
    </sql>

    <sql id="aclUsageDtoColumns">
        df_acl_usage_uid,
        u.df_acl_usage_batch_uid,
        usage_origin,
        channel,
        period,
        original_detail_id,
        wr_wrk_inst,
        system_title,
        u.detail_licensee_class_id,
        dlc.description detail_licensee_class_name,
        alc.aggregate_licensee_class_id,
        alc.description aggregate_licensee_class_name,
        survey_country,
        u.publication_type_uid pub_type_id,
        pt.name pub_type_name,
        pt.description pub_type_description,
        content_unit_price,
        type_of_use,
        annualized_copies,
        u.quantity,
        is_editable,
        u.created_datetime,
        u.updated_datetime,
        u.created_by_user,
        u.updated_by_user,
        u.record_version
    </sql>

    <sql id="selectCountByFilterSql">
        select count(1)
        from ${schema}.df_acl_usage u
        join ${schema}.df_acl_usage_batch ub on u.df_acl_usage_batch_uid = ub.df_acl_usage_batch_uid
        join ${schema}.df_detail_licensee_class dlc on u.detail_licensee_class_id = dlc.detail_licensee_class_id
        join ${schema}.df_aggregate_licensee_class alc on dlc.aggregate_licensee_class_id = alc.aggregate_licensee_class_id
        left join ${schema}.df_publication_type pt on u.publication_type_uid = pt.df_publication_type_uid
        <include refid="IAclUsageMapper.aclUsageFilter"/>
    </sql>

    <sql id="selectDtosByFilterSql">
        select
            <include refid="IAclUsageMapper.aclUsageDtoColumns"/>
        from ${schema}.df_acl_usage u
        join ${schema}.df_acl_usage_batch ub on u.df_acl_usage_batch_uid = ub.df_acl_usage_batch_uid
        join ${schema}.df_detail_licensee_class dlc on u.detail_licensee_class_id = dlc.detail_licensee_class_id
        join ${schema}.df_aggregate_licensee_class alc on dlc.aggregate_licensee_class_id = alc.aggregate_licensee_class_id
        left join ${schema}.df_publication_type pt on u.publication_type_uid = pt.df_publication_type_uid
        <include refid="IAclUsageMapper.aclUsageFilter"/>
        order by
        <choose>
            <when test="null != sort">
                <include refid="IAclUsageMapper.chooseSortProperty"/>
            </when>
            <otherwise>
                updated_datetime desc
            </otherwise>
        </choose>,
        df_acl_usage_uid
        <include refid="IUsageMapper.ifPageable"/>
    </sql>

    <sql id="aclUsageFilter">
        <where>
            <if test="null != filter.usageBatchName">
                and ub.name = #{filter.usageBatchName}
            </if>
        </where>
        <if test="null != filter.usageOrigin">
            and u.usage_origin = #{filter.usageOrigin}
        </if>
        <if test="null != filter.channel">
            and u.channel = #{filter.channel}
        </if>
        <if test="null != filter.periods and filter.periods.size() > 0">
            and
            <foreach collection="filter.periods" item="period" open="(" separator=" or " close=")">
                u.period = #{period}
            </foreach>
        </if>
        <if test="null != filter.detailLicenseeClasses and filter.detailLicenseeClasses.size() > 0">
            and
            <foreach collection="filter.detailLicenseeClasses" item="detailLicenseeClass" open="(" separator=" or " close=")">
                u.detail_licensee_class_id = #{detailLicenseeClass.id}
            </foreach>
        </if>
        <if test="null != filter.aggregateLicenseeClasses and filter.aggregateLicenseeClasses.size() > 0">
            and
            <foreach collection="filter.aggregateLicenseeClasses" item="aggregateLicenseeClass" open="(" separator=" or " close=")">
                dlc.aggregate_licensee_class_id = #{aggregateLicenseeClass.id}
            </foreach>
        </if>
        <if test="null != filter.pubTypes and filter.pubTypes.size() > 0">
            and
            <foreach collection="filter.pubTypes" item="pubType" open="(" separator=" or " close=")">
                pt.name = #{pubType.name}
            </foreach>
        </if>
        <if test="null != filter.typeOfUses and filter.typeOfUses.size() > 0">
            and
            <foreach collection="filter.typeOfUses" item="typeOfUse" open="(" separator=" or " close=")">
                u.type_of_use = #{typeOfUse}
            </foreach>
        </if>
        <if test="!filter.usageDetailIdExpression.isEmpty()">
            <include refid="IUdmCommonMapper.textFieldFilterExpression">
                <property name="column" value="u.original_detail_id"/>
                <property name="operator" value="filter.usageDetailIdExpression.operator"/>
                <property name="fieldFirstValue" value="${filter.usageDetailIdExpression.fieldFirstValue}"/>
                <property name="fieldSecondValue" value="${filter.usageDetailIdExpression.fieldSecondValue}"/>
            </include>
        </if>
        <if test="!filter.wrWrkInstExpression.isEmpty()">
            <include refid="IUdmCommonMapper.numericFieldFilterExpression">
                <property name="column" value="u.wr_wrk_inst"/>
                <property name="operator" value="filter.wrWrkInstExpression.operator"/>
                <property name="fieldFirstValue" value="${filter.wrWrkInstExpression.fieldFirstValue}"/>
                <property name="fieldSecondValue" value="${filter.wrWrkInstExpression.fieldSecondValue}"/>
            </include>
        </if>
        <if test="!filter.systemTitleExpression.isEmpty()">
            <include refid="IUdmCommonMapper.textFieldFilterExpression">
                <property name="column" value="u.system_title"/>
                <property name="operator" value="filter.systemTitleExpression.operator"/>
                <property name="fieldFirstValue" value="${filter.systemTitleExpression.fieldFirstValue}"/>
                <property name="fieldSecondValue" value="${filter.systemTitleExpression.fieldSecondValue}"/>
            </include>
        </if>
        <if test="!filter.surveyCountryExpression.isEmpty()">
            <include refid="IUdmCommonMapper.textFieldFilterExpression">
                <property name="column" value="u.survey_country"/>
                <property name="operator" value="filter.surveyCountryExpression.operator"/>
                <property name="fieldFirstValue" value="${filter.surveyCountryExpression.fieldFirstValue}"/>
                <property name="fieldSecondValue" value="${filter.surveyCountryExpression.fieldSecondValue}"/>
            </include>
        </if>
        <if test="!filter.contentUnitPriceExpression.isEmpty()">
            <include refid="IUdmCommonMapper.numericFieldFilterExpression">
                <property name="column" value="u.content_unit_price"/>
                <property name="operator" value="filter.contentUnitPriceExpression.operator"/>
                <property name="fieldFirstValue" value="${filter.contentUnitPriceExpression.fieldFirstValue}"/>
                <property name="fieldSecondValue" value="${filter.contentUnitPriceExpression.fieldSecondValue}"/>
            </include>
        </if>
        <if test="!filter.annualizedCopiesExpression.isEmpty()">
            <include refid="IUdmCommonMapper.numericFieldFilterExpression">
                <property name="column" value="u.annualized_copies"/>
                <property name="operator" value="filter.annualizedCopiesExpression.operator"/>
                <property name="fieldFirstValue" value="${filter.annualizedCopiesExpression.fieldFirstValue}"/>
                <property name="fieldSecondValue" value="${filter.annualizedCopiesExpression.fieldSecondValue}"/>
            </include>
        </if>
    </sql>

    <sql id="chooseSortProperty">
        <choose>
            <when test="sort.property == 'detailId'">
                df_acl_usage_uid <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'period'">
                period <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'usageOrigin'">
                usage_origin <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'channel'">
                channel <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'usageDetailId'">
                original_detail_id <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'wrWrkInst'">
                wr_wrk_inst <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'systemTitle'">
                system_title <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'detLcId'">
                u.detail_licensee_class_id <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'detLcName'">
                dlc.description <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'aggLcId'">
                alc.aggregate_licensee_class_id <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'aggLcName'">
                alc.description <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'surveyCountry'">
                survey_country <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'publicationType'">
                pt.name <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'contentUnitPrice'">
                content_unit_price <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'typeOfUse'">
                type_of_use <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'annualizedCopies'">
                annualized_copies <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'updateUser'">
                u.updated_by_user <include refid="IUsageMapper.direction"/>
            </when>
            <when test="sort.property == 'updateDate'">
                u.updated_datetime <include refid="IUsageMapper.direction"/>
            </when>
        </choose>
    </sql>

    <select id="findDefaultUsageAgesWeights" resultMap="aclDefaultUsageAgeWeightResultMap">
        select
            period_prior,
            weight
        from ${schema}.df_udm_age_weight
    </select>

    <sql id="rightsholderAclTotalHoldersOrderBy">
        order by
        <choose>
            <when test="null != sort">
                <choose>
                    <when test="sort.property == 'rightsholder.name'">
                        r.name <include refid="IUsageMapper.direction"/>
                    </when>
                    <when test="sort.property == 'rightsholder.accountNumber'">
                        shd.rh_account_number <include refid="IUsageMapper.direction"/>
                    </when>
                    <when test="sort.property == 'grossTotalPrint'">
                        gross_total_print <include refid="IUsageMapper.direction"/>
                    </when>
                    <when test="sort.property == 'serviceFeeTotalPrint'">
                        service_fee_total_print <include refid="IUsageMapper.direction"/>
                    </when>
                    <when test="sort.property == 'netTotalPrint'">
                        net_total_print <include refid="IUsageMapper.direction"/>
                    </when>
                    <when test="sort.property == 'grossTotalDigital'">
                        gross_total_digital <include refid="IUsageMapper.direction"/>
                    </when>
                    <when test="sort.property == 'serviceFeeTotalDigital'">
                        service_fee_total_digital <include refid="IUsageMapper.direction"/>
                    </when>
                    <when test="sort.property == 'netTotalDigital'">
                        net_total_digital <include refid="IUsageMapper.direction"/>
                    </when>
                    <when test="sort.property == 'numberOfTitles'">
                        number_of_titles <include refid="IUsageMapper.direction"/>
                    </when>
                    <when test="sort.property == 'numberOfAggLcClasses'">
                        number_of_agg_lc_classes <include refid="IUsageMapper.direction"/>
                    </when>
                    <when test="sort.property == 'licenseType'">
                        s.license_type <include refid="IUsageMapper.direction"/>
                    </when>
                </choose>,
                r.name
            </when>
            <otherwise>
                r.name
            </otherwise>
        </choose>
    </sql>

    <sql id="searchWhereClause">
        (r.name ilike '%' || #{searchValue} || '%' or
        cast(shd.rh_account_number as text) like '%' || #{searchValue} || '%')
    </sql>

    <select id="populateAclUsages" parameterType="map" resultType="string">
        insert into ${schema}.df_acl_usage (
            <include refid="aclUsageColumns"/>
        )
        select
            uuid_generate_v4(),
            #{usageBatchId},
            ub.usage_origin,
            ub.channel,
            u.period,
            u.original_detail_id,
            u.wr_wrk_inst,
            u.system_title,
            u.detail_licensee_class_id,
            u.survey_country,
            vb.publication_type_uid,
            vb.content_unit_price,
            u.type_of_use,
            u.annualized_copies,
            u.quantity,
            <include refid="StoredEntityMapper.insert"/>
        from ${schema}.df_udm_usage u
        join ${schema}.df_udm_usage_batch ub on u.df_udm_usage_batch_uid = ub.df_udm_usage_batch_uid
        left join ${schema}.df_udm_value_baseline vb on u.df_udm_value_uid = vb.df_udm_value_baseline_uid
        where u.is_baseline_flag = true
            and
            <foreach collection="periods" item="period" open="(" separator=" or " close=")">
                u.period = #{period}
            </foreach>
        returning df_acl_usage_uid
    </select>

    <update id="update" parameterType="AclUsageDto">
        update ${schema}.df_acl_usage
        set
            period = #{period},
            wr_wrk_inst = #{wrWrkInst},
            detail_licensee_class_id = #{detailLicenseeClass.id},
            publication_type_uid = #{publicationType.id},
            content_unit_price = #{contentUnitPrice},
            type_of_use = #{typeOfUse},
            annualized_copies = #{annualizedCopies},
            <include refid="StoredEntityMapper.update"/>
        where df_acl_usage_uid = #{id}
    </update>

    <select id="findByIds" resultMap="aclUsageDtoResultMap">
        select
            <include refid="IAclUsageMapper.aclUsageDtoColumns"/>
        from ${schema}.df_acl_usage u
        join ${schema}.df_acl_usage_batch ub on u.df_acl_usage_batch_uid = ub.df_acl_usage_batch_uid
        left join ${schema}.df_publication_type pt on u.publication_type_uid = pt.df_publication_type_uid
        join ${schema}.df_detail_licensee_class dlc on u.detail_licensee_class_id = dlc.detail_licensee_class_id
        join ${schema}.df_aggregate_licensee_class alc on dlc.aggregate_licensee_class_id = alc.aggregate_licensee_class_id
        where df_acl_usage_uid in
            <foreach collection="list" item="usageId" open="(" separator="," close=")">
                #{usageId}
            </foreach>
        order by original_detail_id
    </select>

    <select id="findCountByFilter" parameterType="map" resultType="int">
        <include refid="IAclUsageMapper.selectCountByFilterSql"/>
    </select>

    <select id="findDtosByFilter" resultMap="aclUsageDtoResultMap" parameterType="map" fetchSize="${usageSelectFetchSize}">
        <include refid="IAclUsageMapper.selectDtosByFilterSql"/>
    </select>

    <select id="findPeriods" resultType="int">
        select distinct period
        from ${schema}.df_acl_usage
        order by period desc
    </select>

   <!-- todo  move all scenario related queries to separate AclScenarioUsageMapper-->
    <select id="findAclRightsholderTotalsHoldersByScenarioId" parameterType="map" resultMap="aclRightsholderTotalsHolderResultMap">
        select
            shd.rh_account_number,
            r.name rh_name,
            sum(case when shd.type_of_use = 'PRINT' then coalesce(shd.gross_amount, 0) else 0 end) as gross_total_print,
            sum(case when shd.type_of_use = 'PRINT' then coalesce(shd.service_fee_amount, 0) else 0 end) as service_fee_total_print,
            sum(case when shd.type_of_use = 'PRINT' then coalesce(shd.net_amount, 0) else 0 end) as net_total_print,
            sum(case when shd.type_of_use = 'DIGITAL' then coalesce(shd.gross_amount, 0) else 0 end) as gross_total_digital,
            sum(case when shd.type_of_use = 'DIGITAL' then coalesce(shd.service_fee_amount, 0) else 0 end) as service_fee_total_digital,
            sum(case when shd.type_of_use = 'DIGITAL' then coalesce(shd.net_amount, 0) else 0 end) as net_total_digital,
            count(distinct system_title) number_of_titles,
            count(distinct aggregate_licensee_class_id) number_of_agg_lc_classes,
            s.license_type
        from ${schema}.df_acl_scenario s
        join ${schema}.df_acl_scenario_detail scd on s.df_acl_scenario_uid = scd.df_acl_scenario_uid
        join ${schema}.df_acl_share_detail shd on scd.df_acl_scenario_detail_uid = shd.df_acl_scenario_detail_uid
        left join ${schema}.df_rightsholder r on shd.rh_account_number = r.rh_account_number
        where s.df_acl_scenario_uid = #{scenarioId}
            <if test="null != searchValue">
                and <include refid="IAclUsageMapper.searchWhereClause"/>
            </if>
        group by
            shd.rh_account_number,
            rh_name,
            s.license_type
        <include refid="IAclUsageMapper.rightsholderAclTotalHoldersOrderBy"/>
        <include refid="IUsageMapper.ifPageable"/>
    </select>

    <select id="findAclRightsholderTotalsHolderCountByScenarioId" parameterType="map" resultType="int">
        select
            count(distinct shd.rh_account_number)
        from ${schema}.df_acl_scenario s
        join ${schema}.df_acl_scenario_detail scd on s.df_acl_scenario_uid = scd.df_acl_scenario_uid
        join ${schema}.df_acl_share_detail shd on scd.df_acl_scenario_detail_uid = shd.df_acl_scenario_detail_uid
        left join ${schema}.df_rightsholder r on shd.rh_account_number = r.rh_account_number
        where s.df_acl_scenario_uid = #{scenarioId}
            <if test="null != searchValue">
                and <include refid="IAclUsageMapper.searchWhereClause"/>
            </if>
    </select>

    <sql id="periodPriorSql">
        <!--Gets period_prior for each usage 'years interval * 12 + month interval / 6'  for example: 202212 and 202012 returns 4-->
        select (
            extract(year from age(to_date(${period}::text, 'YYYYMM'), to_date(u.period::text, 'YYYYMM')::timestamp)) * 12 +
            extract(month from age(to_date(${period}::text, 'YYYYMM'), to_date(u.period::text, 'YYYYMM')::timestamp))
        ) / 6
    </sql>

    <insert id="addToScenario" parameterType="map">
        insert into ${schema}.df_acl_scenario_detail (
            df_acl_scenario_detail_uid,
            df_acl_scenario_uid,
            period_end_date,
            original_detail_id,
            wr_wrk_inst,
            system_title,
            detail_licensee_class_id,
            publication_type_uid,
            content_unit_price,
            usage_quantity,
            usage_age_weight,
            survey_country,
            weighted_copies,
           <include refid="StoredEntityMapper.additionalColumns"/>
        )
        select distinct on (u.df_acl_usage_uid)
            uuid_generate_v4() df_acl_scenario_detail_uid,
            #{scenario.id} df_acl_scenario_uid,
            u.period period_end_date,
            original_detail_id,
            u.wr_wrk_inst,
            u.system_title,
            detail_licensee_class_id,
            publication_type_uid,
            content_unit_price,
            quantity,
            uaw.weight usage_age_weight,
            survey_country,
            uaw.weight * quantity weighted_copies,
            <include refid="StoredEntityMapper.insert"/>
        from ${schema}.df_acl_usage u
        join ${schema}.df_acl_grant_set ags on ags.df_acl_grant_set_uid = #{scenario.grantSetId}
        join ${schema}.df_acl_grant_detail gd on ags.df_acl_grant_set_uid = gd.df_acl_grant_set_uid
            and gd.wr_wrk_inst = u.wr_wrk_inst
            and gd.grant_status = 'GRANT'
            and gd.is_eligible = true
        join ${schema}.df_acl_scenario_usage_age_weight uaw on uaw.df_acl_scenario_uid = #{scenario.id}
            and uaw.period_prior = (
                <include refid="periodPriorSql">
                    <property name="period" value="#{scenario.periodEndDate}"/>
                </include>
            )
        where df_acl_usage_batch_uid = #{scenario.usageBatchId}
            and uaw.weight > 0
            and quantity &lt; 2000
    </insert>

    <update id="populatePubTypeWeights" parameterType="map">
        with pub_type_weights_period_range as materialized (
            select
                df_publication_type_uid,
                weight,
                period as start_period,
                coalesce(lead(period - 1, 1) over (partition by df_publication_type_uid order by period), 209912) as end_period
            from ${schema}.df_acl_scenario_pub_type_weight
        )
        update ${schema}.df_acl_scenario_detail sd
        set
            pub_type_weight = (
                select range.weight
                from pub_type_weights_period_range range
                where range.df_publication_type_uid = sd.publication_type_uid
                    and sd.period_end_date between range.start_period and range.end_period
            ),
            <include refid="StoredEntityMapper.update"/>
        where df_acl_scenario_uid = #{scenarioId}
    </update>

    <insert id="addScenarioShares" parameterType="map">
        insert into ${schema}.df_acl_share_detail (
            df_acl_share_detail_uid,
            df_acl_scenario_uid,
            df_acl_scenario_detail_uid,
            type_of_use,
            rh_account_number,
            aggregate_licensee_class_id,
            volume_weight,
            value_weight,
            <include refid="StoredEntityMapper.additionalColumns"/>
        )
        select
            uuid_generate_v4() df_acl_share_detail_uid,
            #{scenario.id} df_acl_scenario_uid,
            sd.df_acl_scenario_detail_uid,
            gd.type_of_use,
            gd.rh_account_number,
            slc.aggregate_licensee_class_id,
            usage_quantity * usage_age_weight volume_weight,
            usage_quantity * usage_age_weight * content_unit_price * pub_type_weight value_weight,
            <include refid="StoredEntityMapper.insert"/>
        from ${schema}.df_acl_scenario_detail sd
        join ${schema}.df_acl_grant_set ags on ags.df_acl_grant_set_uid = #{scenario.grantSetId}
        join ${schema}.df_acl_scenario_licensee_class slc on sd.df_acl_scenario_uid = slc.df_acl_scenario_uid
            and sd.detail_licensee_class_id = slc.detail_licensee_class_id
        join ${schema}.df_acl_grant_detail gd on ags.df_acl_grant_set_uid = gd.df_acl_grant_set_uid
            and gd.wr_wrk_inst = sd.wr_wrk_inst
            and gd.grant_status = 'GRANT'
            and gd.is_eligible = true
        where sd.df_acl_scenario_uid = #{scenario.id}
    </insert>

    <update id="calculateScenarioShares" parameterType="map">
        with denominators as materialized (
            select
                type_of_use,
                aggregate_licensee_class_id,
                coalesce(sum(volume_weight), 1) as volume_weight_denominator,
                coalesce(sum(value_weight), 1) as value_weight_denominator
            from ${schema}.df_acl_share_detail
            where df_acl_scenario_uid = #{scenarioId}
            group by type_of_use, aggregate_licensee_class_id
        )
        update ${schema}.df_acl_share_detail sh
        set
            volume_share = volume_weight / d.volume_weight_denominator,
            value_share = value_weight / d.value_weight_denominator,
            detail_share = (volume_weight / d.volume_weight_denominator + value_weight / d.value_weight_denominator) / 2,
            <include refid="StoredEntityMapper.update"/>
        from denominators d
        where sh.df_acl_scenario_uid = #{scenarioId}
            and d.aggregate_licensee_class_id = sh.aggregate_licensee_class_id
            and d.type_of_use = sh.type_of_use
    </update>

    <update id="calculateScenarioAmounts" parameterType="map">
        with agg_class_amounts as materialized (
            select
                default_det.aggregate_licensee_class_id,
                fpd.type_of_use,
                sum(fpd.net_amount) net_amount,
                sum(fpd.gross_amount) gross_amount
            from ${schema}.df_acl_scenario s
            join ${schema}.df_acl_fund_pool_detail fpd on s.df_acl_fund_pool_uid = fpd.df_acl_fund_pool_uid
            join ${schema}.df_detail_licensee_class default_det on fpd.detail_licensee_class_id = default_det.detail_licensee_class_id
            where df_acl_scenario_uid = #{scenarioId}
            group by fpd.type_of_use, default_det.aggregate_licensee_class_id
        )
        update ${schema}.df_acl_share_detail sh
        set
            net_amount = detail_share * amounts.net_amount,
            gross_amount = detail_share * amounts.gross_amount,
            service_fee_amount = detail_share * amounts.gross_amount - detail_share * amounts.net_amount,
            <include refid="StoredEntityMapper.update"/>
        from agg_class_amounts amounts
        where sh.df_acl_scenario_uid  = #{scenarioId}
            and amounts.aggregate_licensee_class_id = sh.aggregate_licensee_class_id
            and amounts.type_of_use = sh.type_of_use
    </update>

    <select id="findScenarioDetailsByScenarioId" resultMap="aclScenarioDetailResultMap">
        select
            sd.df_acl_scenario_detail_uid,
            sd.df_acl_scenario_uid,
            period_end_date,
            original_detail_id,
            wr_wrk_inst,
            system_title,
            sd.detail_licensee_class_id,
            dlc.description detail_licensee_class_name,
            slc.aggregate_licensee_class_id,
            alc.description aggregate_licensee_class_name,
            sd.publication_type_uid,
            pub_type_weight,
            content_unit_price,
            usage_quantity,
            usage_age_weight,
            weighted_copies,
            survey_country,
            shd.rh_account_number,
            shd.type_of_use,
            shd.volume_weight,
            shd.value_weight,
            shd.value_share,
            shd.volume_share,
            shd.detail_share,
            shd.volume_weight_denominator,
            shd.value_weight_denominator,
            shd.net_amount,
            shd.gross_amount,
            shd.service_fee_amount
        from ${schema}.df_acl_scenario_detail sd
        left join ${schema}.df_acl_share_detail shd on sd.df_acl_scenario_detail_uid = shd.df_acl_scenario_detail_uid
        join ${schema}.df_acl_scenario_pub_type_weight spt on sd.df_acl_scenario_uid = spt.df_acl_scenario_uid
            and sd.publication_type_uid = spt.df_publication_type_uid
        join ${schema}.df_acl_scenario_licensee_class slc on sd.df_acl_scenario_uid = slc.df_acl_scenario_uid
            and sd.detail_licensee_class_id = slc.detail_licensee_class_id
        join ${schema}.df_detail_licensee_class dlc on slc.detail_licensee_class_id = dlc.detail_licensee_class_id
        join ${schema}.df_aggregate_licensee_class alc on slc.aggregate_licensee_class_id = alc.aggregate_licensee_class_id
        where sd.df_acl_scenario_uid = #{scenarioId}
        order by original_detail_id, shd.type_of_use
    </select>

    <select id="findCountInvalidUsages" parameterType="map" resultType="int">
        select count(1)
        from ${schema}.df_acl_usage u
        join ${schema}.df_acl_usage_batch ub on u.df_acl_usage_batch_uid  = ub.df_acl_usage_batch_uid
        join ${schema}.df_acl_grant_detail gd on  gd.df_acl_grant_set_uid = #{grantSetId}
            and gd.wr_wrk_inst = u.wr_wrk_inst
            and grant_status = 'GRANT'
            and is_eligible = true
        where u.df_acl_usage_batch_uid = #{batchId}
            and (u.publication_type_uid is null or u.content_unit_price is null)
            and
                <foreach collection="periodPriors" item="periodPrior" open="(" separator=" or " close=")">
                   #{periodPrior} = (
                        <include refid="periodPriorSql">
                            <property name="period" value="#{distributionPeriod}"/>
                        </include>
                    )
                </foreach>
            and u.quantity &lt; 2000
    </select>
</mapper>
