package com.copyright.rup.dist.foreign.ui.servlet;

import com.copyright.rup.common.exception.RupRuntimeException;
import com.copyright.rup.common.logging.RupLogUtils;
import com.copyright.rup.dist.common.service.api.scheduler.ISchedulerService;
import com.copyright.rup.dist.common.service.api.scheduler.ScheduledJobStatus;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.net.HttpHeaders;
import com.google.common.net.MediaType;

import org.apache.commons.lang3.exception.ExceptionUtils;
import org.quartz.SchedulerException;
import org.slf4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.util.StreamUtils;
import org.springframework.web.context.support.WebApplicationContextUtils;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.NoSuchElementException;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * REST service for scheduled jobs workflow, API-compatible with Spring MVC solution generated by Swagger Codegen.
 * <p>
 * Copyright (C) 2019 copyright.com
 * <p>
 * Date: 02/14/2019
 *
 * @author Aliaksanr Liakh
 */
// TODO {aliakh} replace with Spring MVC implementation after resolving issues with springSecurityFilterChain
@WebServlet(value = "/jobs/*")
public class JobsRestServlet extends HttpServlet {

    private static final Logger LOGGER = RupLogUtils.getLogger();
    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    @Autowired
    private ISchedulerService schedulerService;

    @Override
    public void init(final ServletConfig config) throws ServletException {
        super.init(config);
        WebApplicationContextUtils.getWebApplicationContext(config.getServletContext())
            .getAutowireCapableBeanFactory()
            .autowireBean(this);
    }

    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        respond(request, response, jobName -> {
            ScheduledJobStatus status = schedulerService.getJobStatus(jobName);
            if (ScheduledJobStatus.RUNNING.equals(status)) {
                respondSuccess(response, "RUNNING", HttpStatus.ACCEPTED);
            } else {
                respondSuccess(response, "WAITING", HttpStatus.OK);
            }
        });
    }

    @Override
    public void doPost(HttpServletRequest request, HttpServletResponse response) {
        respond(request, response, jobName -> {
            ScheduledJobStatus status = schedulerService.triggerJob(jobName);
            if (ScheduledJobStatus.RUNNING.equals(status)) {
                respondSuccess(response, "RUNNING", HttpStatus.ACCEPTED);
            } else {
                respondSuccess(response, "TRIGGERED", HttpStatus.OK);
            }
        });
    }

    private void respond(HttpServletRequest request, HttpServletResponse response, IConsumer<String> consumer) {
        if ("/jobs".equals(request.getServletPath())) {
            String pathInfo = request.getPathInfo();
            if (null != pathInfo && '/' == pathInfo.charAt(0)) {
                String jobName = pathInfo.substring(1);
                try {
                    consumer.consume(jobName);
                } catch (NoSuchElementException e) {
                    respondError(response, e, HttpStatus.NOT_FOUND);
                } catch (SchedulerException e) {
                    respondError(response, new RupRuntimeException(e), HttpStatus.INTERNAL_SERVER_ERROR);
                }
            }
        }
    }

    private void respondSuccess(HttpServletResponse response, String status, HttpStatus httpStatus) {
        JobStatus jobStatus = new JobStatus();
        jobStatus.setStatus(status);
        response.setStatus(httpStatus.value());
        respond(response, jobStatus);
    }

    private void respondError(HttpServletResponse response, Exception e, HttpStatus httpStatus) {
        ErrorStatus errorStatus = new ErrorStatus();
        errorStatus.setError(httpStatus.name());
        String message = e.getMessage();
        errorStatus.setMessage(message);
        errorStatus.setStackTrace(ExceptionUtils.getStackTrace(e));
        LOGGER.warn(message, e);
        response.setStatus(httpStatus.value());
        respond(response, errorStatus);
    }

    private void respond(HttpServletResponse response, Object object) {
        try {
            response.setHeader(HttpHeaders.CACHE_CONTROL, "no-cache");
            response.setContentType(MediaType.JSON_UTF_8.toString());
            String body = OBJECT_MAPPER.writer().writeValueAsString(object);
            // to fix XSS_SERVLET code vulnerability found by FindBugs
            StreamUtils.copy(body, StandardCharsets.UTF_8, response.getOutputStream());
        } catch (IOException e) {
            throw new RupRuntimeException(e);
        }
    }

    @FunctionalInterface
    private interface IConsumer<T> {

        void consume(T t) throws SchedulerException;
    }
}
